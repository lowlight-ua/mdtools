"""A very simple model of a markdown file tree."""

from pathlib import Path
from typing import List, Dict, Tuple
import re
import marko # type: ignore

###############################################################################

RE_ANCHOR_NAME = r"""=(?:\s*['"]([^'"]*?)['"]|\s*([^'">]*?)(?:\s|>))"""
rc_anchor_name = re.compile(RE_ANCHOR_NAME)

# Classes to hold information about the markdown tree.

class Anchor:
    """Represents an anchor in a markdown file"""

    name: str

    def __init__(self, html: str) -> None:
        # The name part of the anchor (e.g. "anchor_name")

        match = rc_anchor_name.search(html)
        if match:
            self.name = match.group(1) or match.group(2)
            

class Link:
    """Represents a link in a markdown file. Wraps a Link or Image node in the Marko AST."""

    # "Link" object in the Marko document
    m_link: marko.inline.Link

    def __init__(self, m_link: marko.inline.Link):
        self.m_link = m_link

    def get_dest(self) -> str:
        """Get the destination string from the link. Destination is
        'hello.md#world' from '[text](<hello.md#world> "label).
        """
        return self.m_link.dest

    def set_dest(self, dest: str) -> None:
        """Set the destination string of the link."""
        self.m_link.dest = dest

    def get_href(self) -> str:
        """Get the href string from the link. Href is
        'hello.md' from '[text](<hello.md#world> "label).
        """
        href, _ = Link.split_link(self.get_dest())
        return href

    def get_anchor(self) -> str:
        """Get the href string from the link. Anchor is
        'world' from '[text](<hello.md#world> "label).
        """
        _, anchor = Link.split_link(self.get_dest())
        return anchor

    def set_href(self, href: str) -> None:
        """Set the href string of the link."""
        _, anchor = Link.split_link(self.get_dest())
        dest = href + (('#' + anchor) if anchor else '')
        self.set_dest(dest)

    def set_anchor(self, anchor: str) -> None:
        """Set the anchor string of the link."""
        href, _ = Link.split_link(self.get_dest())
        dest = href + (('#' + anchor) if anchor else '')
        self.set_dest(dest)

    def is_absolute(self) -> bool:
        """Return true if the link is absolute."""
        return self.get_dest()[0:1] == '/'

    def is_local(self) -> bool:
        """Return true if the link is local (assumed local if contains no colons)."""
        return self.get_href().find(':') == -1

    @staticmethod
    def split_link(linkstr: str) -> Tuple[str, str]:
        """Split the part in the round brackets into the href and the anchor
        (e.g. "hello.md#world -> "hello.md", "world")
        """

        href_split = linkstr.split('#')
        href = href_split[0]
        anchor = href_split[1] if len(href_split)>1 else ''
        return href, anchor

class File:
    """Represents a file or directory in a file tree."""

    # Path to the file.
    path:               Path

    # If this is markdown file, - all anchors in this file
    anchors:            Dict[str, Anchor]

    # If this is markdown file, - all headings in this file
    h_anchors:          Dict[str, Anchor]

    # If this is markdown file, - all links in this file
    links:              List[Link]

    # Markdown parser and renderer for this file. Used to parse the markdown, as well as
    # to generate an updated markdown after fixing issues (which is why it's being stored).
    marko:              marko.Markdown

    # The root node of the markdown AST, produced by `marko`.
    m_document:         marko.block.Document

    def __init__(self, path: Path):
        self.path = path        # pathlib Path
        self.anchors = {}
        self.h_anchors = {}
        self.links = []
        self.marko = None
        self.m_document = None

    def on_anchor(self, anchor: Anchor) -> None:
        """Called during file parsing if an anchor is found."""
        self.anchors[anchor.name] = anchor

    def on_heading_anchor(self, anchor: Anchor) -> None:
        """Called during file parsing if a heading anchor is found."""
        self.h_anchors[anchor.name] = anchor

    def on_link(self, link: Link) -> None:
        """Called during file parsing if a link is found."""
        self.links.append(link)


class MdTree:
    """Contains data about a markdown file tree."""

    # Base path of the markdown tree.
    base:        Path

    # All files in the file tree.
    files:       Dict[Path, File]

    # All file names in the file tree
    # (where file name is "hello.md" in "C:/Documents/hello.md").
    # Maps from file name to all Files that have this name.
    # Used for auto fixing.
    names:       Dict[str,  List[Path]]

    # All anchors in the file tree.
    # Maps from file name to all Files that have this anchor.
    # Used for auto fixing.
    anchors:     Dict[str,  List[Path]]

    # All anchors autogenerated from headings in the file tree.
    # Maps from file name to all Files that have this anchor.
    # Used for auto fixing.
    h_anchors:   Dict[str,  List[Path]]

    # All anchors combined
    all_anchors: Dict[str,  List[Path]]

    def __init__(self, base: str) -> None:
        self.base = Path(base).resolve()
        self.files = {}
        self.names = {}
        self.anchors = {}
        self.h_anchors = {}
        self.all_anchors = {}

    def on_file(self, path: Path) -> File:
        """Called for each file when traversing a file tree."""
        file = File(path)
        self.files[path] = file
        self.names.setdefault(path.name, []).append(path)
        return file

    def on_anchor(self, path: Path, anchor: Anchor) -> None:
        """Called during file parsing if an anchor is found."""
        self.files[path].on_anchor(anchor)
        self.anchors.setdefault(anchor.name, []).append(path)

    def on_heading_anchor(self, path: Path, anchor: Anchor) -> None:
        """Called during file parsing if a heading is found."""
        self.files[path].on_heading_anchor(anchor)
        self.h_anchors.setdefault(anchor.name, []).append(path)

    def on_link(self, path: Path, link: Link) -> None:
        """Called during file parsing if a link is found."""
        self.files[path].on_link(link)
